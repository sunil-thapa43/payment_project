from django.core.validators import MinValueValidator, MaxValueValidator
from django.db import models

from payment.views import handle_grpc_write
from utils.enums import PaymentVendor, PaymentStatus


class NavyaBaseModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)


# For now, we are taking the payment partners as enum choices, but this model can be used for future reference
# Best possible usecase for this model: When frontend requests for available payment partners, we only send them the
# payment partners that are working (a. our code breaks for the payment partner, b. the payment partners are down or have
# some issues), in these cases we can only give option to pay via working Payment Partners

# class PaymentPartners(NavyaBaseModel):
#     name = models.CharField(max_length=100, help_text=_('Name of partner: lets keep the name in lowercase like esewa khalti connectips imepay'))
#     symbol = models.CharField(max_length=100)
#     active = models.BooleanField(default=True)
#     description = models.TextField()
#
#     class Meta:
#         verbose_name_plural = _('Payment Partner Details')
#         ordering = ['-created_at']
#
#     def __str__(self):
#         return self.name


class PaymentRequest(NavyaBaseModel):
    # class PaymentStatusChoices(models.TextChoices):
    #     """ Completed means both our database and the merchants' response matches the transaction amount.
    #     When frontend requests for transaction details, the payment request is initially set to Initiated.
    #     Other Flags will be set according to the payment requests response from the merchants side typically
    #     caught from our success or failure urls.
    #     """
    #     COMPLETED = 'COMPLETED'
    #     INITIATED = 'INITIATED'
    #     REJECTED = 'REJECTED'
    #     FAILED = 'FAILED'
    #     CANCELLED = 'CANCELLED'
    payment_partner = models.TextField(
        choices=PaymentVendor.choices(), null=True, blank=True
    )
    # not sure whether the other service will send user id
    user_id = models.IntegerField(null=True, blank=True)
    purpose = models.CharField(max_length=400, blank=True, null=True)
    remarks = models.TextField(null=True, blank=True)
    amount = models.DecimalField(
        decimal_places=2, max_digits=25, null=False, blank=False
    )
    # partners like khalti and connectIPS take amount in paisa, might be useful to store amount in paisa for future reference
    amount_in_paisa = models.DecimalField(
        decimal_places=2, max_digits=30, null=True, blank=True
    )
    transaction_id = models.CharField(max_length=100, blank=False, null=False)
    status = models.TextField(choices=PaymentStatus.choices(), blank=False, null=False)
    signature = models.TextField(null=True, blank=True)

    def __str__(self):
        return f"Payment Request for User: {self.user_id} of Amount: {self.amount}"

    class Meta:
        verbose_name_plural = "Payment Requests"


class Payment(NavyaBaseModel):
    """
    Our architecture is Microservices, we are writing to the db of other services when payment is completed. This db is
    also maintained for cross-reference and future usages.
    This model/db_table is only populated once our respective success URL is hit from the payment merchants' side and
    the details are cross-checked against Payment Request db table.
    """

    request = models.ForeignKey(PaymentRequest, on_delete=models.CASCADE)
    amount = models.DecimalField(
        decimal_places=2, max_digits=10, null=False, blank=False
    )
    amount_in_paisa = models.DecimalField(decimal_places=2, max_digits=10)
    transaction_id = models.CharField(max_length=100, blank=False, null=False)
    user_id = models.IntegerField(blank=False, null=False)

    def __str__(self):
        return f"Payment for User: {self.user_id} - Amount: ${self.amount}"

    class Meta:
        verbose_name_plural = "Payments"


class ImePayDetails(NavyaBaseModel):
    """
    Straight from IMEPay Docs:
    Merchant should maintain a database table to store responses received from IME pay. The
    table must contain following columns in exact table format as mentioned below. The records
    of each transaction are stored on this Db table with an added feature to recheck the
    transactions (explained on step 7). This allows merchants to reconfirm and complete the
    failed transactions, which may have occurred due to various reasons.

    MerchantCode VARCHAR(10) Will be provided by IME Pay
    TranAmount MONEY Amount involved in the transaction
    RefId VARCHAR(20) Unique id generated by merchant’s system
    TokenId VARCHAR(20 Will be provided by IME Pay at the end of Step 1
    TransactionId VARCHAR(20) IME Pay Unique Id returned after successful payment
    Msisdn VARCHAR(20) IME Pay Wallet Id returned after successful payment
    ImeTxnStatus TinyInt 0-Success,1-Failed,2-Error,3-Cancelled
    RequestDate DATETIME DateTime of Merchant’s request
    ResponseDate DATETIME DateTime of IME Pay response
    """
    transaction_amount = models.DecimalField(
        decimal_places=2, max_digits=10, null=False, blank=False
    )
    # according to the docs, the ref_id is the transaction_id that we generate, and transaction_id for IMEPay
    # is the id generated by the IMEPay, quite confusing but it is what it is
    ref_id = models.CharField(max_length=20, null=False, blank=False)
    token_id = models.CharField(max_length=20, null=True, blank=True)
    transaction_id = models.CharField(max_length=20, null=False, blank=False)
    msisdn = models.CharField(max_length=20, null=True, blank=True)
    ime_transaction_status = models.PositiveSmallIntegerField(
        validators=[MinValueValidator(0), MaxValueValidator(4)], blank=True, null=True
    )
    request_date = models.DateTimeField(auto_now_add=True)
    response_date = models.DateTimeField(null=True, blank=True)

    class Meta:
        verbose_name_plural = "IME Pay Details"